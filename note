addSegment(Segment)

find trapeziod according to 2 endpoints (start, end)

if trapeziod from 2 are same -> insert by Segment is within endpoints
else insert by hard case


simpleCase(node,Segment)

create 4 new trapeziod and replace the search tree


hardCase(leftmost_node, rightmost_node, Segment)

1. (left)add new trapeziod by using tr begin as base, set right Point to Segment start
2. (top) add new trapeziod by using tr begin as base, set leftpoint  to Segment start, bot to Segment itself, create node
3. (bot) add new trapeziod by using tr begin as base, set leftpoint  to Segment start, top to Segment itself, create node

4. set neighbors of leftmost(1) to 2 and 3
5. at old begin node (leftmost_node), change trapeziod to 1
6. for tr of 2, 3 set left neighbors to 1

	6.1. create new x, y node 

		GraphNode* newLeft = new XNode(Segment->ptLeft.x);
		GraphNode* newSplit = new YNode(Segment);
		newLeft->attachLeft(new TerminalNode(trLeftmost));
		newLeft->attachRight(newSplit);
		newSplit->attachLeft(terminalTop);
		newSplit->attachRight(terminalBot);

	6.2. for looping all intersected Segment
		change top, bot accordingly by checking neighbors

		end if loop is pointing to last tr

		create y node and replace with node at tree

7. do same to rightmost


Replacing node by get all parents of graphnode
	

// if last tr has rightBot && rightTop
if (trPrev->trRightBot && trPrev->trRightTop)
	{
		// renewTop = if neighbor right bot of last tr is current trapeziod that Segment intersect so it's top has to be fixed
		renewTop = (trPrev->trRightBot == trCurrent);
	}
	else
	{
		assert(trCurrent->trLeftBot == trPrev || trCurrent->trLeftTop == trPrev);
		// renewTop = if neighbor left bot of current tr is last tr
		renewTop = (trCurrent->trLeftBot == trPrev);
	}
}


if (renewTop)
{
	// if we have to renew top,

	// set rightpoint of top to trCurrent left
	trMergeTop->right = trCurrent->left;
	Trapezoid* oldMergeTop = trMergeTop; //??
	//
	trMergeTop = new Trapezoid(*trCurrent);
	terminalTop = new TerminalNode(trMergeTop);
	trMergeTop->bot = Segment;

	if (trCurrent->trLeftBot && trCurrent->trLeftTop)
	{
		oldMergeTop->setOneRight(trMergeTop);
		trMergeTop->trLeftBot = oldMergeTop;
		trMergeTop->trLeftTop = trCurrent->trLeftTop;
		trCurrent->trLeftTop->setOneRight(trMergeTop);
		assert(trMergeTop->trLeftTop);
	}
	else
	{
		oldMergeTop->trRightBot = trMergeTop;
		oldMergeTop->trRightTop = trPrev->trRightTop;
		trPrev->trRightTop->setOneLeft(oldMergeTop);
		trMergeTop->setOneLeft(oldMergeTop);
	}
}
